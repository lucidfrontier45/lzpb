// Generated by Gemini 2.5 Pro

package main

import (
	"archive/zip"
	"bytes"
	"flag"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"
)

const (
	VERSION         = "0.1.1"
	RUN_SH          = "run.sh"
	BOOTSTRAP       = "bootstrap"
	DEFAULT_EXEC    = "bootstrap,run.sh"
	EXEC_PERMISSION = 0o755
)

type packOptions struct {
	execFiles string
}

var opts = packOptions{
	execFiles: DEFAULT_EXEC,
}

func parseExecFiles(execFiles string) []string {
	if execFiles == "" {
		return []string{}
	}
	parts := strings.Split(execFiles, ",")
	result := make([]string, 0, len(parts))
	for _, p := range parts {
		trimmed := strings.TrimSpace(p)
		if trimmed != "" {
			result = append(result, trimmed)
		}
	}
	return result
}

func init() {
	flag.StringVar(
		&opts.execFiles,
		"exec",
		DEFAULT_EXEC,
		"Comma-separated list of files to set executable permissions",
	)
}

// zipDirectory compresses the entire contents of the sourceDir directory
// into a zip file named targetZipFile.
//
// If files are specified via --exec flag, they are given Unix executable
// permissions (0755). The default is "bootstrap,run.sh".
func zipDirectory(sourceDir, targetZipFile string, execFiles []string) error {
	// 1. Create the target zip file. It will overwrite if it already exists.
	zipFile, err := os.Create(targetZipFile)
	if err != nil {
		return err
	}
	defer func() {
		if err := zipFile.Close(); err != nil {
			fmt.Fprintln(os.Stderr, "Error closing zip file:", err)
		}
	}()

	// 2. Initialize a new zip.Writer to write to the zip file.
	zipWriter := zip.NewWriter(zipFile)
	defer func() {
		if err := zipWriter.Close(); err != nil {
			fmt.Fprintln(os.Stderr, "Error closing zip writer:", err)
		}
	}()

	// Use the clean path of the source directory as the base.
	baseDir := filepath.Clean(sourceDir)

	// Track which exec files were found for warning about missing files.
	foundExecFiles := make(map[string]bool)

	// 3. Walk through all the files and directories recursively.
	err = filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Don't include the source directory itself in the zip archive.
		if path == baseDir {
			return nil
		}

		// 4. Create a zip FileHeader from the FileInfo.
		header, err := zip.FileInfoHeader(info)
		if err != nil {
			return err
		}

		// 5. Set the file name in the header to be a relative path from the source directory.
		relPath, err := filepath.Rel(baseDir, path)
		if err != nil {
			return err
		}
		// Use forward slashes for path separators for cross-platform compatibility.
		header.Name = filepath.ToSlash(relPath)

		if info.IsDir() {
			// If it's a directory, add a trailing slash to the name.
			header.Name += "/"
		} else {
			// If it's a file, set the compression method (Deflate is common).
			header.Method = zip.Deflate

			// 6. Grant executable permissions to specified files.
			for _, execFile := range execFiles {
				if info.Name() == execFile {
					header.SetMode(EXEC_PERMISSION)
					foundExecFiles[execFile] = true
					break
				}
			}
		}

		// 7. Write the header to the zip writer.
		writer, err := zipWriter.CreateHeader(header)
		if err != nil {
			return err
		}

		// 8. If it's not a directory, write the file's content.
		if !info.IsDir() {
			file, err := os.Open(path)
			if err != nil {
				return err
			}
			defer func() {
				if err := file.Close(); err != nil {
					fmt.Fprintln(os.Stderr, "Error closing file:", err)
				}
			}()

			// If the file is "run.sh", convert its line endings to LF before writing.
			if info.Name() == RUN_SH {
				// Read the entire file content into memory.
				content, err := io.ReadAll(file)
				if err != nil {
					return err
				}

				// Replace CRLF (\r\n) with LF (\n).
				crlf := []byte{'\r', '\n'}
				lf := []byte{'\n'}
				content = bytes.ReplaceAll(content, crlf, lf)

				// Write the modified content to the zip archive.
				_, err = writer.Write(content)
				if err != nil {
					return err
				}
			} else {
				// For all other files, copy the content directly.
				_, err = io.Copy(writer, file)
				if err != nil {
					return err
				}
			}
		}

		return nil
	})
	if err != nil {
		return err
	}

	// Warn about exec files that were not found in the source directory.
	for _, execFile := range execFiles {
		if !foundExecFiles[execFile] {
			fmt.Fprintf(
				os.Stderr,
				"Warning: exec file '%s' not found in source directory\n",
				execFile,
			)
		}
	}

	return nil
}

func main() {
	flag.Parse()
	// get cmd arguments
	args := flag.Args()
	if len(args) < 2 {
		fmt.Println("Usage: lzpb [--exec=files] <source_dir> <target_zip>")
		return
	}
	sourceDir := args[0]
	targetZip := args[1]
	execFiles := parseExecFiles(opts.execFiles)
	if err := zipDirectory(sourceDir, targetZip, execFiles); err != nil {
		fmt.Fprintln(os.Stderr, "Error creating zip file:", err)
		return
	}
}
